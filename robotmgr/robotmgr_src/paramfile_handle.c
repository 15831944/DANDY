/////////////////////////////////////////////////////////////////////////////
//
//  paramfile_handle.c: Parameter File Handling Function
//                                            2014.06.12  Ryu SinWook

///////////////////////////////////////
#define _USE_MATH_DEFINES
#include "service.h"
#include <math.h>

///////////////////////////////////////


///////////////////////////////////////
//Global_variable

/////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////
//
//  Function: SVC_SaveUserParamConfigToFile()
//      - Service Name: RSVC_SERV_HOME_EDIT
//                      RSVC_SERV_USERCRD_EDIT
//                      RSVC_SERV_PARAM_EDIT

int SVC_SaveUserParamConfigToFile(int nRobot)
{
    static const char szFileComment[] = 
        "# This file is for User Parameters info\n"
        "#  - TCP, WorldCoord, UserCoord, Home Position etc.\n"
        "# Copyright (c) 2013 "
        "Daewoo Shipbuilding and Marine Engineering Co., Ltd.,\n"
        "# * param index is equal to robot index [Unit: mm, deg]\n"
        "#   Caution! Do not edit this file manually!!\n"
        "#   Can be modified by RM Service Request, automatically generated\n"
        "\n";
    int     iIdx, iAxis;
    FILE*   fp;
    char szUserParamFileName[PATH_NAME_BUFFER_SIZE] = "";

#if defined(_MSC_VER)
    errno_t errno;
#endif

    if(g_pShm_SysConfig == NULL || g_pShm_SysParam == NULL)
    {
        VERBOSE_ERROR("Cannot open Shared Memory!\n");
        SVC_DefineErrorState(ON, SVC_ERR_USER_PARAM_SAVING);
        return SVC_ERR_USER_PARAM_SAVING;
    }

    if (g_nConfigLoadOption == OPTION_SYSCONFIG_LOAD &&
        g_fConfigLoadCheck != RESULT_OK)
    {
        VERBOSE_ERROR("Cannot write user param file, Because config file is invalid!\n");

        SVC_DefineErrorState(ON, SVC_ERR_USER_PARAM_SAVING);
        return SVC_ERR_USER_PARAM_SAVING;
    }

    DANDY_ASSERT(nRobot >= 0 && nRobot < MAX_ROBOT_COUNT);
    
    memcpy(szUserParamFileName, g_pszWorkDir, strlen(g_pszWorkDir)+1);

    // Absolute path define
    CRT_strcat(szUserParamFileName, PATH_NAME_BUFFER_SIZE, DEF_USERPARAM_FILENAME);

#if defined(__QNXNTO__)
    fp = fopen(szUserParamFileName, "w+t");
#else
    errno = fopen_s(&fp, szUserParamFileName, "w+t");
#endif
    
    if (fp == NULL)
    {
        VERBOSE_ERROR("Cannot open user param file for write : '%s'\n",
                      DEF_USERPARAM_FILENAME);
        SVC_DefineErrorState(ON, SVC_ERR_USER_PARAM_SAVING);
        return SVC_ERR_USER_PARAM_SAVING;
    }
    else
    {
        VERBOSE_MESSAGE("Open Done! param file for write : '%s'\n",
                        szUserParamFileName);
    }
    
    // write comment
    fputs(szFileComment, fp);

    // section
    fprintf(fp, "[param%d]\n\n", nRobot + 1);
    fprintf(fp, "#####################################################\n");
    
    ////////////////
    // field
    
    //////////////////////////////////////////////////////////////////////
    // JOB_NAME = xxxx.pgm

    fputs(SYSCONF_KEY_LOADED_JOB_NAME " = ", fp);

    fprintf(fp, "%s\n", g_pszLoadedJobFileName);
    
    fprintf(fp, "##################### Euler Values ##################\n");

    //////////////////////////////////////////////////////////////////////
    // TCP = 1.111111 2.222222, 3.333333, ... (x, y, z, roll, pitch, yaw)

    fputs(SYSCONF_KEY_ROBOT_COORD_TCP " = ", fp);

    fprintf(fp, "%5.2lf, %5.2lf, %5.2lf, %5.2lf, %5.2lf, %5.2lf\n",
                 g_pShm_SysConfig->robot->coordTool.x,
                 g_pShm_SysConfig->robot->coordTool.y,
                 g_pShm_SysConfig->robot->coordTool.z,
                 g_pShm_SysConfig->robot->coordTool.rol * (180/M_PI),
                 g_pShm_SysConfig->robot->coordTool.pit * (180/M_PI),
                 g_pShm_SysConfig->robot->coordTool.yaw * (180/M_PI));


    //////////////////////////////////////////////////////////////////////
    // WORLD = 1.11, 2.22, 3.33, .... (x, y, z, roll, pitch, yaw)

    fputs(SYSCONF_KEY_ROBOT_COORD_WORLD " = ", fp);

    fprintf(fp, "%5.2lf, %5.2lf, %5.2lf, %5.2lf, %5.2lf, %5.2lf\n",
                 g_pShm_SysConfig->robot->world.x,
                 g_pShm_SysConfig->robot->world.y,
                 g_pShm_SysConfig->robot->world.z,
                 g_pShm_SysConfig->robot->world.rol * (180/M_PI),
                 g_pShm_SysConfig->robot->world.pit * (180/M_PI),
                 g_pShm_SysConfig->robot->world.yaw * (180/M_PI));

    //////////////////////////////////////////////////////////////////////
    // CART = 1.11, 2.22, 3.33, .... (x, y, z, roll, pitch, yaw)

    fputs(SYSCONF_KEY_ROBOT_COORD_CART " = ", fp);

    fprintf(fp, "%5.2lf, %5.2lf, %5.2lf, %5.2lf, %5.2lf, %5.2lf\n",
                 g_CartOffset.x,
                 g_CartOffset.y,
                 g_CartOffset.z,
                 g_CartOffset.rol,
                 g_CartOffset.pit,
                 g_CartOffset.yaw);
    fprintf(fp, "\n");

    ///////////////////////////////////////////////////////
    // RESTART_INFO =  Moving Type,
    //                 Hroz_OverLapDistance, Vert_OverLapDistance, PathSpeed,
    //                 Horiz_Start_Volt, Horiz_Start_Curr,
    //                 Horiz_Main_Volt,  Horiz_Main_Curr,
    //                 Vert_Start_Volt,  Vert_Start_Curr,
    //                 Vert_Main_Volt,   Vert_Main_Curr
    fprintf(fp, "################# Restart Parameters ################\n");
    fprintf(fp, "# %s= Moving Type[0: Joint, 1: Linear], Hroz_OverLapDistance, Vert_OverLapDistance, PathSpeed,\n",
                SYSCONF_KEY_ROBOT_RESTART_INFO);
    fprintf(fp, "#            Horiz_Start_Volt, Horiz_Start_Curr, Horiz_Main_Volt, Horiz_Main_Curr,\n");
    fprintf(fp, "#            Vert_Start_Volt,  Vert_Start_Curr,  Vert_Main_Volt,  Vert_Main_Curr\n");

    fputs(SYSCONF_KEY_ROBOT_RESTART_INFO " = ", fp);

    if(g_pShm_SysParam->TE_restart[nRobot].moving_type == RESTART_MOVE_TYPE_LIN)
    {
        fprintf(fp, "%d, %.2lf, %.2lf, %.2lf, ",
                    g_pShm_SysParam->TE_restart[nRobot].moving_type,
                    g_pShm_SysParam->TE_restart[nRobot].d_overlap_horz,
                    g_pShm_SysParam->TE_restart[nRobot].d_overlap_vert,
                    g_pShm_SysParam->TE_restart[nRobot].path_speed * 1000);
    }
    else if(g_pShm_SysParam->TE_restart[nRobot].moving_type == RESTART_MOVE_TYPE_JNT)
    {
        fprintf(fp, "%d, %.2lf, %.2lf, %.2lf, ",
                    g_pShm_SysParam->TE_restart[nRobot].moving_type,
                    g_pShm_SysParam->TE_restart[nRobot].d_overlap_horz,
                    g_pShm_SysParam->TE_restart[nRobot].d_overlap_vert,
                    g_pShm_SysParam->TE_restart[nRobot].path_speed * 100);
    }

    fprintf(fp, "%.2lf, %.2lf, %.2lf, %.2lf, %.2lf, %.2lf, %.2lf, %.2lf\n",
                 g_pShm_SysParam->TE_restart[nRobot].hori_start_vol,
                 g_pShm_SysParam->TE_restart[nRobot].hori_start_cur,
                 g_pShm_SysParam->TE_restart[nRobot].hori_main_vol,
                 g_pShm_SysParam->TE_restart[nRobot].hori_main_cur,
                 g_pShm_SysParam->TE_restart[nRobot].vert_start_vol,
                 g_pShm_SysParam->TE_restart[nRobot].vert_start_cur,
                 g_pShm_SysParam->TE_restart[nRobot].vert_main_vol,
                 g_pShm_SysParam->TE_restart[nRobot].vert_main_cur);
    fprintf(fp, "\n");

    fprintf(fp, "################ ArcSensor Parameters ###############\n");
    fprintf(fp, "# %s= Save Data Flag, Start Node Number, Save Node Count\n",
                SYSCONF_KEY_ARCSENSOR_SAVENODE);
    //////////////////////////////////////////////////////////////////////
    // SAVE_NODE =  1, 8, 200
    fputs(SYSCONF_KEY_ARCSENSOR_SAVENODE " = ", fp);

    fprintf(fp, "%d, %d, %d\n",
            g_pShm_SysParam->arcsensor[nRobot].fSaveArcSensorData,
            g_pShm_SysParam->arcsensor[nRobot].nStartSaveNodeNo,
            g_pShm_SysParam->arcsensor[nRobot].nSaveNodeCount);
    fprintf(fp, "\n");

    fprintf(fp, "################ Weld Tune Parameters ###############\n");

    fprintf(fp, "# Applied Weld Tuning Parameter Index: In index, Out index\n");
    //////////////////////////////////////////////////////////////////////
    // TUNE_APPLY_IDX = IN, OUT
    fputs(SYSCONF_KEY_WELD_TUNE_INDEX " = ", fp);

    fprintf(fp, "%d, %d\n",
                g_pShm_SysParam->nWeldTuneInParamApplyIndex,
                g_pShm_SysParam->nWeldTuneOutParamApplyIndex);
    fprintf(fp, "\n");

    fprintf(fp, "# Weld Input Tuning Parameters: a, b, Scale, Offset\n");
    for (iIdx = 0; iIdx < MAX_WELDER_COUNT; iIdx++)
    {
        //////////////////////////////////////////////////////////////////////
        // TUNE_VOLT_IN = Volt_a, Volt_b, Volt_Scale, Volt_Offset
        fputs(SYSCONF_KEY_WELD_TUNE_VOLT_IN " = ", fp);

        fprintf(fp, "%d> %.10lf, %.10lf, %.10lf, %.10lf\n",
                     iIdx,
                     g_pShm_SysParam->weld_tune[iIdx].input.dbVolt_a,
                     g_pShm_SysParam->weld_tune[iIdx].input.dbVolt_b,
                     g_pShm_SysParam->weld_tune[iIdx].input.dbVoltScale,
                     g_pShm_SysParam->weld_tune[iIdx].input.dbVoltOffset);

        //////////////////////////////////////////////////////////////////////
        // TUNE_CURR_IN = Curr_a, Curr_b, Curr_Scale, Curr_Offset

        fputs(SYSCONF_KEY_WELD_TUNE_CURR_IN " = ", fp);

        fprintf(fp, "%d> %.10lf, %.10lf, %.10lf, %.10lf\n",
                     iIdx,
                     g_pShm_SysParam->weld_tune[iIdx].input.dbCurr_a,
                     g_pShm_SysParam->weld_tune[iIdx].input.dbCurr_b,
                     g_pShm_SysParam->weld_tune[iIdx].input.dbCurrScale,
                     g_pShm_SysParam->weld_tune[iIdx].input.dbCurrOffset);
        fprintf(fp, "\n");
    }

    
    fprintf(fp, "# Weld Output Tuning Parameters: a, b, c, Scale, Offset\n");
    for (iIdx = 0; iIdx < MAX_WELDER_COUNT; iIdx++)
    {
        //////////////////////////////////////////////////////////////////////
        // TUNE_VOLT_OUT = Volt_a, Volt_b, Volt_c, Volt_Scale, Volt_Offset
        fputs(SYSCONF_KEY_WELD_TUNE_VOLT_OUT " = ", fp);

        fprintf(fp, "%d> %.10lf, %.10lf, %.10lf, %.10lf, %.10lf\n",
                     iIdx,
                     g_pShm_SysParam->weld_tune[iIdx].output.dbVolt_a,
                     g_pShm_SysParam->weld_tune[iIdx].output.dbVolt_b,
                     g_pShm_SysParam->weld_tune[iIdx].output.dbVolt_c,
                     g_pShm_SysParam->weld_tune[iIdx].output.dbVoltScale,
                     g_pShm_SysParam->weld_tune[iIdx].output.dbVoltOffset);

        //////////////////////////////////////////////////////////////////////
        // TUNE_CURR_OUT = Curr_a, Curr_b, Curr_c, Curr_Scale, Curr_Offset

        fputs(SYSCONF_KEY_WELD_TUNE_CURR_OUT " = ", fp);

        fprintf(fp, "%d> %.10lf, %.10lf, %.10lf, %.10lf, %.10lf\n",
                     iIdx,
                     g_pShm_SysParam->weld_tune[iIdx].output.dbCurr_a,
                     g_pShm_SysParam->weld_tune[iIdx].output.dbCurr_b,
                     g_pShm_SysParam->weld_tune[iIdx].output.dbCurr_c,
                     g_pShm_SysParam->weld_tune[iIdx].output.dbCurrScale,
                     g_pShm_SysParam->weld_tune[iIdx].output.dbCurrOffset);
        fprintf(fp, "\n");
    }

    //////////////////////////////////////////////////////////////////////
    // USER = 0> 1.111111 2.222222 3.333333, ... (index> x, y, z, roll, pitch, yaw)
    // USER = 1> 1.111111 2.222222 3.333333, ...

    fprintf(fp, "############### User Coordinate #####################\n");

    for (iIdx = 0; iIdx < MAX_USER_COORD_COUNT; iIdx++)
    {
        fputs(SYSCONF_KEY_ROBOT_COORD_USER " = ", fp);

        fprintf(fp, "%d> %5.2lf, %5.2lf, %5.2lf, %5.2lf, %5.2lf, %5.2lf\n",
                     iIdx,
                     g_pShm_SysConfig->robot->user[iIdx].x,
                     g_pShm_SysConfig->robot->user[iIdx].y,
                     g_pShm_SysConfig->robot->user[iIdx].z,
                     g_pShm_SysConfig->robot->user[iIdx].rol * (180/M_PI),
                     g_pShm_SysConfig->robot->user[iIdx].pit * (180/M_PI),
                     g_pShm_SysConfig->robot->user[iIdx].yaw * (180/M_PI));
    }
    fprintf(fp, "\n");


    //////////////////////////////////////////////////////////////////////
    // HOME = 0> 1.111111 2.222222 3.333333, ... (index> joint1, joint2, ...)
    // HOME = 1> 1.111111 2.222222 3.333333, ...

    fprintf(fp, "################ Home Position ######################\n");
    
    for (iIdx = 0; iIdx < MAX_HOME_COUNT; iIdx++)
    {
        fputs(SYSCONF_KEY_ROBOT_COORD_HOME " = ", fp);

        fprintf(fp, "%d> ", iIdx);
        for (iAxis = 0; iAxis < ROB_AXIS_COUNT; iAxis++)
        {
            fprintf(fp, "%5.2lf",
                    g_pShm_SysConfig->robot->rgdbHomePosVal[iIdx][iAxis] * (180/M_PI));
            if(iAxis != ROB_AXIS_COUNT - 1)
            {
                fprintf(fp, ", ");
            }
        }
        fprintf(fp, "\n");
    }
    fprintf(fp, "\n");

    //////////////////////////////////////////////////////////////////////
    // WELD_MEASURE_VAL = Idx> Volt_Cmd, Volt_Measure, Curr_Cmd, Curr_Measure

    fprintf(fp, "################ Weld Measure Value #################\n");
    fprintf(fp, "# Weld Measure Parameters: Volt_Cmd, Volt_Measure, Curr_Cmd, Curr_Measure\n");

    for (iIdx = 0; iIdx < MAX_WELDER_COUNT; iIdx++)
    {
        fputs(SYSCONF_KEY_WELD_MEASURE_VAL " = ", fp);

        fprintf(fp, "%d> %.4lf, %.4lf, %.4lf, %.4lf\n",
                     iIdx,
                     g_dbControllerCmdVolt[iIdx],
                     g_dbWelderMeasureVolt[iIdx],
                     g_dbControllerCmdCurr[iIdx],
                     g_dbWelderMeasureCurr[iIdx]);
    }
    fprintf(fp, "\n");

    fclose(fp);

    return RESULT_OK;
}


///////////////////////////////////////
//
//  Function: FUNC_ReadRestartParamFromFile()
//

int FUNC_ReadRestartParamFromFile(void)
{
    FILE*   fp;
    char szRestartParamFileName[PATH_NAME_BUFFER_SIZE] = "";
    size_t  result;
    long    nFileSize;

    if(g_pShmemTE_Restart == NULL)
    {
        VERBOSE_ERROR("Cannot open Restart shared memory! Fail to Read File!\n");
        SVC_DefineErrorState(ON, SYS_ERR_OPEN_RESTART_PARAM);
        return SYS_ERR_OPEN_RESTART_PARAM;
    }

    memcpy(szRestartParamFileName, g_pszWorkDir, strlen(g_pszWorkDir)+1);

    // Absolute path define
    CRT_strcat(szRestartParamFileName,
               PATH_NAME_BUFFER_SIZE,
               DEF_RESTARTPARAM_FILENAME);

#if defined(__QNXNTO__)
    fp = fopen(szRestartParamFileName, "rb");
#else
    errno = fopen_s(&fp, szRestartParamFileName, "rb");
#endif
    
    if (fp == NULL)
    {
        VERBOSE_ERROR("Cannot open restart param file for read : '%s'\n",
                      DEF_RESTARTPARAM_FILENAME);
        SVC_DefineErrorState(ON, SYS_ERR_OPEN_RESTART_PARAM);
        return SYS_ERR_OPEN_RESTART_PARAM;
    }
    else
    {
        VERBOSE_MESSAGE("Open Done! restart param file for read : '%s'\n",
                        szRestartParamFileName);
    }

    // obtain file size:
    fseek (fp , 0 , SEEK_END);
    nFileSize = ftell (fp);
    rewind (fp);

    result = fread((BYTE*) g_pShmemTE_Restart,
                   sizeof(BYTE),
                   g_nLoadSizeRestartSHM,
                   fp);

    VERBOSE_MESSAGE("restart param file data read Done! (size: %d)\n",
                     result);

    fclose(fp);

    return RESULT_OK;
}


///////////////////////////////////////
//
//  Function: FUNC_SaveRestartParamToFile()
//

int FUNC_SaveRestartParamToFile(void)
{
    FILE*   fp;
    char szRestartParamFileName[PATH_NAME_BUFFER_SIZE] = "";
    size_t  result;

    if(g_pShmemTE_Restart == NULL)
    {
        VERBOSE_ERROR("Cannot open Restart shared memory! Fail to Save File!\n");
        SVC_DefineErrorState(ON, SVC_ERR_RESTART_PARAM_SAVING);
        return SVC_ERR_RESTART_PARAM_SAVING;
    }

    memcpy(szRestartParamFileName, g_pszWorkDir, strlen(g_pszWorkDir)+1);

    // Absolute path define
    CRT_strcat(szRestartParamFileName,
               PATH_NAME_BUFFER_SIZE,
               DEF_RESTARTPARAM_FILENAME);

#if defined(__QNXNTO__)
    fp = fopen(szRestartParamFileName, "wb");
#else
    errno = fopen_s(&fp, szRestartParamFileName, "wb");
#endif
    
    if (fp == NULL)
    {
        VERBOSE_ERROR("Cannot open restart param file for write : '%s'\n",
                      DEF_RESTARTPARAM_FILENAME);
        SVC_DefineErrorState(ON, SVC_ERR_RESTART_PARAM_SAVING);
        return SVC_ERR_RESTART_PARAM_SAVING;
    }
    else
    {
        VERBOSE_MESSAGE("Open Done! restart param file for write : '%s'\n",
                        szRestartParamFileName);
    }

    result = fwrite((BYTE*) g_pShmemTE_Restart,
                    sizeof(BYTE),
                    g_nLoadSizeRestartSHM,
                    fp);

    VERBOSE_MESSAGE("restart param file data write Done! (size: %d)\n",
                     result);

    fclose(fp);

    return RESULT_OK;
}


///////////////////////////////////////
//
//  Function: FUNC_SaveConstVarToFile()
//

int FUNC_SaveConstVarToFile(int nVarType)
{
    FILE*   fp;
    char    szContVarFileName[PATH_NAME_BUFFER_SIZE] = "";
    size_t  result;
    SHM_DANDY_JOB*  pShmem = g_pShmemJobRM;
    unsigned long   dwShmemSize;
    
    DANDY_JOB_POS*  pPVarStart;
    BYTE*           pBVarStart;
    INT *           pIVarStart;
    double*         pRVarStart;

    if(pShmem == NULL)
    {
        VERBOSE_ERROR("Cannot open const variables shared memory! Fail to Save File!\n");
        SVC_DefineErrorState(ON, SVC_ERR_CONST_VAR_SAVING);
        return SVC_ERR_CONST_VAR_SAVING;
    }

    memcpy(szContVarFileName, g_pszWorkDir, strlen(g_pszWorkDir)+1);

    pPVarStart = GET_SHM_JOB_PVA_BUFFER(pShmem);
    pBVarStart = GET_SHM_JOB_BVA_BUFFER(pShmem);
    pIVarStart = GET_SHM_JOB_IVA_BUFFER(pShmem);
    pRVarStart = GET_SHM_JOB_RVA_BUFFER(pShmem);

    // Absolute path define
    if(nVarType == OPTION_PVAR)
    {
        CRT_strcat(szContVarFileName,
                   PATH_NAME_BUFFER_SIZE,
                   DEF_CONST_PVAR_FILENAME);
    }
    else if(nVarType == OPTION_BVAR)
    {
        CRT_strcat(szContVarFileName,
                   PATH_NAME_BUFFER_SIZE,
                   DEF_CONST_BVAR_FILENAME);
    }
    else if(nVarType == OPTION_IVAR)
    {
        CRT_strcat(szContVarFileName,
                   PATH_NAME_BUFFER_SIZE,
                   DEF_CONST_IVAR_FILENAME);
    }
    else if(nVarType == OPTION_RVAR)
    {
        CRT_strcat(szContVarFileName,
                   PATH_NAME_BUFFER_SIZE,
                   DEF_CONST_RVAR_FILENAME);
    }

#if defined(__QNXNTO__)
    fp = fopen(szContVarFileName, "wb");
#else
    errno = fopen_s(&fp, szContVarFileName, "wb");
#endif
    
    if (fp == NULL)
    {
        VERBOSE_ERROR("Cannot open const variables file for write : '%s'\n",
                      DEF_RESTARTPARAM_FILENAME);
        SVC_DefineErrorState(ON, SVC_ERR_CONST_VAR_SAVING);
        return SVC_ERR_CONST_VAR_SAVING;
    }
    else
    {
        VERBOSE_MESSAGE("Open Done! const variables file for write : '%s'\n",
                        szContVarFileName);
    }
    
    if(nVarType == OPTION_PVAR)
    {
        dwShmemSize = pShmem->dwPVaSize;
        
        result = fwrite((BYTE*) pPVarStart,
                        sizeof(int) + (sizeof(DOUBLE) * MAX_ROBOT_AXIS_COUNT),
                        dwShmemSize,
                        fp);

        VERBOSE_MESSAGE("const P variables file data write Done! (count: %d)\n",
                         result);
    }
    else if(nVarType == OPTION_BVAR)
    {
        dwShmemSize = pShmem->dwBVaSize;
        
        result = fwrite((BYTE*) pBVarStart,
                        sizeof(BYTE),
                        dwShmemSize,
                        fp);

        VERBOSE_MESSAGE("const B variables file data write Done! (count: %d)\n",
                         result);
    }
    else if(nVarType == OPTION_IVAR)
    {
        dwShmemSize = pShmem->dwIVaSize;
        
        result = fwrite((BYTE*) pIVarStart,
                        sizeof(INT),
                        dwShmemSize,
                        fp);

        VERBOSE_MESSAGE("const I variables file data write Done! (count: %d)\n",
                         result);
    }
    else if(nVarType == OPTION_RVAR)
    {
        dwShmemSize = pShmem->dwRVaSize;
        
        result = fwrite((BYTE*) pRVarStart,
                        sizeof(DOUBLE),
                        dwShmemSize,
                        fp);

        VERBOSE_MESSAGE("const R variables file data write Done! (count: %d)\n",
                         result);
    }

    fclose(fp);

    return RESULT_OK;
}


///////////////////////////////////////
//
//  Function: FUNC_ReadConstVarFromFile()
//

int FUNC_ReadConstVarFromFile(int nVarType)
{
    FILE*   fp;
    char    szContVarFileName[PATH_NAME_BUFFER_SIZE] = "";
    SHM_DANDY_JOB*  pShmem = g_pShmemJobRM;
    size_t  result;
    long    nFileSize;
    unsigned long   dwShmemSize;

    DANDY_JOB_POS*  pPVarStart;
    BYTE*           pBVarStart;
    INT *           pIVarStart;
    double*         pRVarStart;

    if(pShmem == NULL)
    {
        VERBOSE_ERROR("Cannot open Restart shared memory! Fail to Read File!\n");
        SVC_DefineErrorState(ON, SYS_ERR_OPEN_CONST_VAR);
        return SYS_ERR_OPEN_CONST_VAR;
    }

    memcpy(szContVarFileName, g_pszWorkDir, strlen(g_pszWorkDir)+1);

    pPVarStart = GET_SHM_JOB_PVA_BUFFER(pShmem);
    pBVarStart = GET_SHM_JOB_BVA_BUFFER(pShmem);
    pIVarStart = GET_SHM_JOB_IVA_BUFFER(pShmem);
    pRVarStart = GET_SHM_JOB_RVA_BUFFER(pShmem);

    // Absolute path define
    if(nVarType == OPTION_PVAR)
    {
        CRT_strcat(szContVarFileName,
                   PATH_NAME_BUFFER_SIZE,
                   DEF_CONST_PVAR_FILENAME);
    }
    else if(nVarType == OPTION_BVAR)
    {
        CRT_strcat(szContVarFileName,
                   PATH_NAME_BUFFER_SIZE,
                   DEF_CONST_BVAR_FILENAME);
    }
    else if(nVarType == OPTION_IVAR)
    {
        CRT_strcat(szContVarFileName,
                   PATH_NAME_BUFFER_SIZE,
                   DEF_CONST_IVAR_FILENAME);
    }
    else if(nVarType == OPTION_RVAR)
    {
        CRT_strcat(szContVarFileName,
                   PATH_NAME_BUFFER_SIZE,
                   DEF_CONST_RVAR_FILENAME);
    }

#if defined(__QNXNTO__)
    fp = fopen(szContVarFileName, "rb");
#else
    errno = fopen_s(&fp, szContVarFileName, "rb");
#endif
    
    if (fp == NULL)
    {
        VERBOSE_ERROR("Cannot open const variables file for read : '%s'\n",
                      DEF_RESTARTPARAM_FILENAME);
        SVC_DefineErrorState(ON, SYS_ERR_OPEN_CONST_VAR);
        return SYS_ERR_OPEN_CONST_VAR;
    }
    else
    {
        VERBOSE_MESSAGE("Open Done! const variables file for read : '%s'\n",
                        szContVarFileName);
    }

    // get file size:
    fseek (fp , 0 , SEEK_END);
    nFileSize = ftell (fp);
    rewind (fp);

    if(nVarType == OPTION_PVAR)
    {
        dwShmemSize = pShmem->dwPVaSize;
        
        result = fread((BYTE*) pPVarStart,
                        sizeof(int) + (sizeof(DOUBLE) * MAX_ROBOT_AXIS_COUNT),
                        dwShmemSize,
                        fp);

        VERBOSE_MESSAGE("const P variables file data read Done! (count: %d)\n",
                         result);
    }
    else if(nVarType == OPTION_BVAR)
    {
        dwShmemSize = pShmem->dwBVaSize;
        
        result = fread((BYTE*) pBVarStart,
                        sizeof(BYTE),
                        dwShmemSize,
                        fp);

        VERBOSE_MESSAGE("const B variables file data read Done! (count: %d)\n",
                         result);
    }
    else if(nVarType == OPTION_IVAR)
    {
        dwShmemSize = pShmem->dwIVaSize;
        
        result = fread((BYTE*) pIVarStart,
                        sizeof(INT),
                        dwShmemSize,
                        fp);

        VERBOSE_MESSAGE("const I variables file data read Done! (count: %d)\n",
                         result);
    }
    else if(nVarType == OPTION_RVAR)
    {
        dwShmemSize = pShmem->dwRVaSize;
        
        result = fread((BYTE*) pRVarStart,
                        sizeof(DOUBLE),
                        dwShmemSize,
                        fp);

        VERBOSE_MESSAGE("const R variables file data read Done! (count: %d)\n",
                         result);
    }

    fclose(fp);

    return RESULT_OK;
}


///////////////////////////////////////
//
//  Function: SVC_ConstVarFileHandle()
//      - Service Name: RSVC_CONSTVAR_FILE_HANDLE

int SVC_ConstVarFileHandle(int nOpt)
{
    int nRet = RESULT_OK;

    if(nOpt == OPTION_READ)
    {
        nRet = FUNC_ReadConstVarFromFile(OPTION_PVAR);
        if(nRet != RESULT_OK)
        {
            VERBOSE_ERROR("P Var File Read Fail!\n");
            return RESULT_ERROR;
        }

        nRet = FUNC_ReadConstVarFromFile(OPTION_BVAR);
        if(nRet != RESULT_OK)
        {
            VERBOSE_ERROR("B Var File Read Fail!\n");
            return RESULT_ERROR;
        }

        nRet = FUNC_ReadConstVarFromFile(OPTION_IVAR);
        if(nRet != RESULT_OK)
        {
            VERBOSE_ERROR("I Var File Read Fail!\n");
            return RESULT_ERROR;
        }

        nRet = FUNC_ReadConstVarFromFile(OPTION_RVAR);
        if(nRet != RESULT_OK)
        {
            VERBOSE_ERROR("R Var File Read Fail!\n");
            return RESULT_ERROR;
        }
    }
    else if(nOpt == OPTION_WRITE)
    {
        nRet = FUNC_SaveConstVarToFile(OPTION_PVAR);
        if(nRet != RESULT_OK)
        {
            VERBOSE_ERROR("P Var File Write Fail!\n");
            return RESULT_ERROR;
        }

        nRet = FUNC_SaveConstVarToFile(OPTION_BVAR);
        if(nRet != RESULT_OK)
        {
            VERBOSE_ERROR("B Var File Write Fail!\n");
            return RESULT_ERROR;
        }

        nRet = FUNC_SaveConstVarToFile(OPTION_IVAR);
        if(nRet != RESULT_OK)
        {
            VERBOSE_ERROR("I Var File Write Fail!\n");
            return RESULT_ERROR;
        }

        nRet = FUNC_SaveConstVarToFile(OPTION_RVAR);
        if(nRet != RESULT_OK)
        {
            VERBOSE_ERROR("R Var File Write Fail!\n");
            return RESULT_ERROR;
        }
    }

    return RESULT_OK;
}
